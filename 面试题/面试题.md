

## 一、面向对象

1. virtual和abstract方法的区别？即虚方法和抽象方法的区别？

   + 虚方法必须有实现部分，抽象方法没有提供实现部分，抽象方法强制子类实现，否则子类不能被实例化。
   + 抽象方法只能在抽象类声明，虚方法不是。如果一个类包含抽象方法，这个类必须声明为抽象类
   + 抽象方法必须在子类中被重写。虚方法可以在子类中被重写、也可以不被重写。
   + 使用虚方法实现多态性时，代码会被解释为运行时代码，程序需要查找对象类型以确定调用的方法。使用抽象方法时，代码会被解释为静态代码，编译器会强制实现所有抽象方法。

   共同点：抽象方法是虚方法的一种，虚方法和抽象方法都是实现多态性的方式。

   参考

   https://blog.csdn.net/LiCcCcCcccCcc/article/details/124800732
   https://blog.csdn.net/xizero00/article/details/6548007
   https://www.jb51.net/article/279217.htm

2. new和override区别？即隐藏方法和重写方法的区别？

+ 重写方法：当你希望子类能够有自己的实现方式，你可以在子类中重写基类中的方法。重写方法需要使用override关键字。重写方法提供了多态性的一种形式。虚方法，抽象方法，带override关键字的方法（也是虚方法的一种）能被重写，实例方法不能被重写。
+ 隐藏方法：当你在基类中声明了一个方法，并且在派生类中又声明了一个与基类同名的方法。隐藏方法不使用override关键字，使用new关键字。隐藏方法不提供多态性。隐藏方法一般是实例方法。

https://www.cnblogs.com/xingyuanzier/p/10269447.html
https://www.51cto.com/article/146714.html

3. overload和override区别？即重载和重写的区别？
   + 所处位置不同：重载是在一个类中，重写在派生类中
   + 定义方式不同：重载方法名相同，参数列表不同，返回类型可不同。重写的两个方法名必须方法名、参数列表、返回值都相同。
   + 调用方式不同：重载使用相同对象以不同参数调用，重写用不同对象、以相同参数调用。
   + 多态时机不同：重载是编译时多态。重写是运行时多态。
   + 重写子类异常不能超过父类相应方法抛出的异常、访问级别不能低于父类方法的访问级别